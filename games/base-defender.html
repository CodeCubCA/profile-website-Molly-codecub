<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flavor Fortress: Defenders of the East - Molly's Arcade</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html {
            overflow-y: auto;
            overflow-x: hidden;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #D2691E 50%, #8B4513 100%);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        body::-webkit-scrollbar { width: 12px; }
        body::-webkit-scrollbar-track { background: #8B4513; border-left: 1px solid rgba(255, 215, 0, 0.2); }
        body::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); border-radius: 10px; }
        body::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%); box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 140, 0, 0.5);
            text-align: center;
        }
        .subtitle {
            font-size: 1.2rem;
            color: #FFA500;
            margin-bottom: 1rem;
            text-align: center;
        }
        .game-container {
            background: rgba(139, 69, 19, 0.6);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4);
            position: relative;
            max-width: 100%;
        }
        canvas {
            border: 3px solid #FFA500;
            background: linear-gradient(135deg, #2F1810 0%, #1a0f08 100%);
            display: block;
            max-width: 100%;
            image-rendering: crisp-edges;
        }
        .hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #FFD700;
        }
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }
        .stat-label {
            font-size: 0.8rem;
            color: #FFA500;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .tower-select {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .tower-btn {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            border: 3px solid #FFD700;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            min-width: 120px;
            text-align: center;
        }
        .tower-btn:hover {
            background: linear-gradient(135deg, #A0522D 0%, #CD853F 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.5);
        }
        .tower-btn.selected {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #8B4513;
            border-color: #FF8C00;
        }
        .tower-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .btn {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #8B4513;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }
        .btn:hover {
            background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid #FFA500;
            max-width: 800px;
        }
        .wave-info {
            text-align: center;
            font-size: 1.1rem;
            color: #FFD700;
            margin-bottom: 10px;
        }
        .chapter-info {
            text-align: center;
            font-size: 1.3rem;
            color: #FF8C00;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139, 69, 19, 0.98);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #FFD700;
            text-align: center;
            display: none;
            z-index: 100;
            max-width: 500px;
        }
        .game-over h2 {
            color: #FFD700;
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 4px solid #FF0000;
            font-size: 2rem;
            color: #FFD700;
            font-weight: bold;
            display: none;
            z-index: 50;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <h1>üçú Flavor Fortress: Defenders of the East ü•¢</h1>
    <p class="subtitle">Defend the Sacred Flavor Core!</p>

    <div class="game-container">
        <div class="chapter-info" id="chapterInfo">Chapter 2: Mizu - Depths of Japanese Delight</div>

        <div class="hud">
            <div class="stat">
                <div class="stat-label">üí∞ Spice Points</div>
                <div class="stat-value" id="money">200</div>
            </div>
            <div class="stat">
                <div class="stat-label">‚ù§Ô∏è Core Health</div>
                <div class="stat-value" id="health">100</div>
            </div>
            <div class="stat">
                <div class="stat-label">üåä Wave</div>
                <div class="stat-value" id="wave">1/10</div>
            </div>
            <div class="stat">
                <div class="stat-label">‚öîÔ∏è Enemies</div>
                <div class="stat-value" id="enemies">0</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="boss-warning" id="bossWarning">‚ö†Ô∏è BOSS WAVE ‚ö†Ô∏è</div>

        <div class="tower-select">
            <button class="tower-btn" onclick="selectTower('sushi')" id="sushiBtn">
                üç£ Sushi Slinger<br><small>üí∞50 | Medium Range</small>
            </button>
            <button class="tower-btn" onclick="selectTower('wok')" id="wokBtn">
                ü•ò Wok Warrior<br><small>üí∞80 | Splash Damage</small>
            </button>
            <button class="tower-btn" onclick="selectTower('ramen')" id="ramenBtn">
                üçú Ramen Rapid<br><small>üí∞100 | Fast Attack</small>
            </button>
            <button class="tower-btn" onclick="selectTower('chopstick')" id="chopstickBtn">
                ü•¢ Chopstick Cannon<br><small>üí∞150 | Long Range</small>
            </button>
            <button class="tower-btn" onclick="selectTower('dragon')" id="dragonBtn">
                üêâ Dragon Tower<br><small>üí∞300 | Ultimate Power</small>
            </button>
        </div>

        <div class="controls">
            <button class="btn" onclick="startWave()" id="startBtn">üöÄ Start Wave</button>
            <button class="btn" onclick="resetGame()">üîÑ Restart</button>
        </div>

        <div class="info">
            <div class="wave-info" id="waveInfo">Click "Start Wave" to begin defending!</div>
            <p style="font-size: 0.9rem; color: #FFA500; margin-top: 10px;">
                üéÆ Click to place towers on the dark areas | üí° Wave 10 features THE DRAGON KING!
            </p>
        </div>

        <div class="game-over" id="gameOver">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p id="gameOverText" style="font-size: 1.5rem; color: #FFA500; margin-bottom: 20px;"></p>
            <button class="btn" onclick="resetGame()">üîÑ Try Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            money: 200,
            health: 100,
            wave: 0,
            maxWaves: 10,
            selectedTower: null,
            towers: [],
            enemies: [],
            projectiles: [],
            particles: [],
            gameActive: true,
            waveActive: false,
            path: [],
            bossActive: false
        };

        // Tower types
        const towerTypes = {
            sushi: { cost: 50, damage: 15, range: 120, fireRate: 60, color: '#FF69B4', emoji: 'üç£' },
            wok: { cost: 80, damage: 25, range: 100, fireRate: 90, color: '#FF8C00', emoji: 'ü•ò', splash: 50 },
            ramen: { cost: 100, damage: 10, range: 100, fireRate: 30, color: '#FFD700', emoji: 'üçú' },
            chopstick: { cost: 150, damage: 40, range: 200, fireRate: 100, color: '#8B4513', emoji: 'ü•¢' },
            dragon: { cost: 300, damage: 60, range: 180, fireRate: 80, color: '#FF0000', emoji: 'üêâ', splash: 80 }
        };

        // Enemy types
        const enemyTypes = {
            lashers: { health: 50, speed: 1.5, reward: 15, color: '#F4A460', emoji: 'üçú', size: 15 },
            tossers: { health: 70, speed: 1.2, reward: 20, color: '#FF6347', emoji: 'üêô', size: 15 },
            onslaught: { health: 120, speed: 0.8, reward: 30, color: '#CD853F', emoji: 'ü•û', size: 18 },
            marshals: { health: 60, speed: 1, reward: 25, color: '#DEB887', emoji: 'üç≤', size: 15 },
            samurai: { health: 200, speed: 0.7, reward: 50, color: '#8B0000', emoji: '‚öîÔ∏è', size: 20 },
            unagi: { health: 40, speed: 2.5, reward: 20, color: '#696969', emoji: 'üêç', size: 12 },
            katsu: { health: 30, speed: 2, reward: 15, color: '#FFD700', emoji: 'üç§', size: 12 },
            // Chapter 3 enemies
            dumpling: { health: 45, speed: 1.6, reward: 18, color: '#F5DEB3', emoji: 'ü•ü', size: 14 },
            wontonWing: { health: 35, speed: 2.2, reward: 22, color: '#FFE4B5', emoji: 'ü¶Ö', size: 13 },
            duck: { health: 150, speed: 0.9, reward: 40, color: '#8B4726', emoji: 'ü¶Ü', size: 19 },
            kungpao: { health: 65, speed: 1.3, reward: 28, color: '#CD5C5C', emoji: 'üå∂Ô∏è', size: 15 },
            // Boss types
            teriyaki: { health: 800, speed: 0.5, reward: 200, color: '#8B4513', emoji: 'üó°Ô∏è', size: 40, boss: true },
            dimsum: { health: 1000, speed: 0.4, reward: 300, color: '#DC143C', emoji: 'üê≤', size: 45, boss: true },
            // Final boss - Dragon King
            dragonKing: { health: 3000, speed: 0.3, reward: 1000, color: '#FF0000', emoji: 'üêâ', size: 60, boss: true, final: true }
        };

        // Create winding path
        function createPath() {
            gameState.path = [
                {x: 0, y: 300},
                {x: 150, y: 300},
                {x: 150, y: 150},
                {x: 350, y: 150},
                {x: 350, y: 450},
                {x: 550, y: 450},
                {x: 550, y: 250},
                {x: 700, y: 250},
                {x: 700, y: 400},
                {x: 800, y: 400}
            ];
        }

        // Draw path with enhanced details
        function drawPath() {
            // Draw decorative bamboo forests around the map
            drawBambooForest();

            // Draw Japanese garden stones
            drawGardenStones();

            // Path outer border (darker)
            ctx.strokeStyle = '#4A3319';
            ctx.lineWidth = 58;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
            for (let i = 1; i < gameState.path.length; i++) {
                ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
            }
            ctx.stroke();

            // Path middle layer
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 50;
            ctx.stroke();

            // Path inner layer (lighter)
            ctx.strokeStyle = '#8B6F47';
            ctx.lineWidth = 46;
            ctx.stroke();

            // Draw path decorations (lanterns)
            drawLanterns();

            // Draw cherry blossom petals
            drawCherryBlossoms();

            // Draw Ramen Shop Base (Flavor Core)
            const goal = gameState.path[gameState.path.length - 1];

            // Base building
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(goal.x - 45, goal.y - 35, 90, 70);

            // Roof
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.moveTo(goal.x - 55, goal.y - 35);
            ctx.lineTo(goal.x, goal.y - 60);
            ctx.lineTo(goal.x + 55, goal.y - 35);
            ctx.closePath();
            ctx.fill();

            // Roof trim
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Door
            ctx.fillStyle = '#654321';
            ctx.fillRect(goal.x - 15, goal.y, 30, 35);

            // Window
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(goal.x - 35, goal.y - 15, 20, 20);
            ctx.fillRect(goal.x + 15, goal.y - 15, 20, 20);

            // Sign
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(goal.x - 25, goal.y - 50, 50, 15);
            ctx.fillStyle = '#8B4513';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('„É©„Éº„É°„É≥', goal.x - 20, goal.y - 38);

            // Steam from building
            if (Math.random() > 0.7) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(goal.x - 20, goal.y - 65, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(goal.x + 20, goal.y - 70, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Flavor Core icon
            ctx.font = '30px Arial';
            ctx.fillText('üçö', goal.x - 15, goal.y + 20);
        }

        // Draw bamboo forest decoration
        function drawBambooForest() {
            const bambooPositions = [
                {x: 50, y: 100}, {x: 70, y: 80}, {x: 90, y: 120},
                {x: 600, y: 520}, {x: 620, y: 540}, {x: 640, y: 500},
                {x: 250, y: 50}, {x: 270, y: 30},
                {x: 450, y: 580}, {x: 470, y: 560}
            ];

            bambooPositions.forEach(pos => {
                // Bamboo stalk
                ctx.fillStyle = '#2F5233';
                ctx.fillRect(pos.x - 3, pos.y - 40, 6, 40);

                // Bamboo segments
                ctx.strokeStyle = '#1a3a1a';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(pos.x - 4, pos.y - (i * 12));
                    ctx.lineTo(pos.x + 4, pos.y - (i * 12));
                    ctx.stroke();
                }

                // Leaves
                ctx.fillStyle = '#4a7c4a';
                ctx.beginPath();
                ctx.ellipse(pos.x - 8, pos.y - 42, 8, 3, -0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(pos.x + 8, pos.y - 45, 8, 3, 0.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Draw garden stones
        function drawGardenStones() {
            const stones = [
                {x: 120, y: 250, r: 15}, {x: 180, y: 380, r: 12},
                {x: 420, y: 200, r: 18}, {x: 480, y: 350, r: 14},
                {x: 650, y: 180, r: 16}, {x: 720, y: 520, r: 13}
            ];

            stones.forEach(stone => {
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(stone.x, stone.y, stone.r, stone.r * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                // Stone highlight
                ctx.fillStyle = 'rgba(169, 169, 169, 0.5)';
                ctx.beginPath();
                ctx.ellipse(stone.x - 3, stone.y - 2, stone.r * 0.4, stone.r * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Draw lanterns along the path
        function drawLanterns() {
            const lanternPositions = [
                {x: 150, y: 200}, {x: 350, y: 100},
                {x: 350, y: 500}, {x: 550, y: 500},
                {x: 550, y: 200}, {x: 700, y: 200}
            ];

            lanternPositions.forEach(pos => {
                // Lantern pole
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x, pos.y - 50);
                ctx.stroke();

                // Lantern body
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.ellipse(pos.x, pos.y - 50, 12, 15, 0, 0, Math.PI * 2);
                ctx.fill();

                // Lantern glow
                ctx.fillStyle = 'rgba(255, 200, 100, 0.6)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y - 50, 8, 0, Math.PI * 2);
                ctx.fill();

                // Lantern top
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(pos.x - 13, pos.y - 66, 26, 4);
            });
        }

        // Draw cherry blossom petals
        function drawCherryBlossoms() {
            const blossoms = [
                {x: 100, y: 150}, {x: 200, y: 100}, {x: 300, y: 120},
                {x: 400, y: 200}, {x: 500, y: 300}, {x: 600, y: 200},
                {x: 150, y: 400}, {x: 450, y: 500}, {x: 700, y: 350}
            ];

            blossoms.forEach(blossom => {
                ctx.fillStyle = 'rgba(255, 182, 193, 0.6)';
                for (let i = 0; i < 5; i++) {
                    const angle = (i * Math.PI * 2) / 5;
                    ctx.beginPath();
                    ctx.ellipse(
                        blossom.x + Math.cos(angle) * 4,
                        blossom.y + Math.sin(angle) * 4,
                        3, 5, angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                // Center
                ctx.fillStyle = 'rgba(255, 223, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(blossom.x, blossom.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Create particle effect
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    color
                });
            }
        }

        // Select tower
        function selectTower(type) {
            gameState.selectedTower = type;
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(type + 'Btn').classList.add('selected');
        }

        // Place tower
        canvas.addEventListener('click', (e) => {
            if (!gameState.selectedTower) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            const tower = towerTypes[gameState.selectedTower];

            // Check if can afford and not on path
            if (gameState.money >= tower.cost && !isOnPath(x, y)) {
                gameState.towers.push({
                    x, y,
                    type: gameState.selectedTower,
                    ...tower,
                    cooldown: 0
                });
                gameState.money -= tower.cost;
                createParticles(x, y, tower.color, 15);
                updateHUD();
            }
        });

        // Check if point is on path
        function isOnPath(x, y) {
            for (let i = 0; i < gameState.path.length - 1; i++) {
                const p1 = gameState.path[i];
                const p2 = gameState.path[i + 1];
                const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                if (dist < 40) return true;
            }
            // Also check Flavor Core
            const goal = gameState.path[gameState.path.length - 1];
            const distToGoal = Math.sqrt((x - goal.x) ** 2 + (y - goal.y) ** 2);
            return distToGoal < 50;
        }

        function distanceToLineSegment(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            const dx = x - xx;
            const dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Start wave
        function startWave() {
            if (gameState.waveActive || !gameState.gameActive) return;

            gameState.wave++;
            if (gameState.wave > gameState.maxWaves) {
                return;
            }

            gameState.waveActive = true;
            document.getElementById('startBtn').disabled = true;

            // Boss waves
            if (gameState.wave === 5) {
                // Teriyaki Titan boss
                spawnBoss('teriyaki', '‚ö†Ô∏è TERIYAKI TITAN APPROACHES! ‚ö†Ô∏è');
            } else if (gameState.wave === 8) {
                // Dim Sum Dragon boss
                spawnBoss('dimsum', '‚ö†Ô∏è DIM SUM DRAGON AWAKENS! ‚ö†Ô∏è');
            } else if (gameState.wave === 10) {
                // FINAL BOSS - Dragon King
                spawnBoss('dragonKing', 'üêâ THE GREAT DRAGON KING NOODLE! üêâ');
                gameState.bossActive = true;
            } else {
                // Regular waves
                const waveSize = 5 + gameState.wave * 2;
                const types = Object.keys(enemyTypes).filter(k => !enemyTypes[k].boss);
                const maxTypeIndex = Math.min(types.length - 1, 2 + Math.floor(gameState.wave / 2));

                for (let i = 0; i < waveSize; i++) {
                    setTimeout(() => {
                        const typeKey = types[Math.floor(Math.random() * (maxTypeIndex + 1))];
                        spawnEnemy(typeKey);
                    }, i * 800);
                }
            }

            updateHUD();
        }

        function spawnBoss(type, message) {
            const warning = document.getElementById('bossWarning');
            warning.textContent = message;
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 3000);

            setTimeout(() => {
                spawnEnemy(type);
            }, 2000);
        }

        function spawnEnemy(typeKey) {
            const enemy = {
                ...enemyTypes[typeKey],
                maxHealth: enemyTypes[typeKey].health,
                pathIndex: 0,
                progress: 0,
                x: gameState.path[0].x,
                y: gameState.path[0].y,
                typeKey
            };
            gameState.enemies.push(enemy);
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('money').textContent = gameState.money;
            document.getElementById('health').textContent = gameState.health;
            document.getElementById('wave').textContent = `${gameState.wave}/${gameState.maxWaves}`;
            document.getElementById('enemies').textContent = gameState.enemies.length;

            // Update tower buttons
            Object.keys(towerTypes).forEach(type => {
                const btn = document.getElementById(type + 'Btn');
                if (gameState.money < towerTypes[type].cost) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
            });
        }

        // Game loop
        function gameLoop() {
            if (!gameState.gameActive) return;

            // Clear canvas with subtle gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2F1810');
            gradient.addColorStop(1, '#1a0f08');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawPath();

            // Update and draw particles
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x, p.y, 3, 3);
                ctx.globalAlpha = 1;

                return p.life > 0;
            });

            // Update and draw enemies
            gameState.enemies = gameState.enemies.filter(enemy => {
                // Move along path
                if (enemy.pathIndex < gameState.path.length - 1) {
                    const current = gameState.path[enemy.pathIndex];
                    const next = gameState.path[enemy.pathIndex + 1];
                    const dx = next.x - current.x;
                    const dy = next.y - current.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const moveX = (dx / dist) * enemy.speed;
                    const moveY = (dy / dist) * enemy.speed;

                    enemy.x += moveX;
                    enemy.y += moveY;

                    const distToNext = Math.sqrt((next.x - enemy.x) ** 2 + (next.y - enemy.y) ** 2);
                    if (distToNext < enemy.speed) {
                        enemy.pathIndex++;
                    }
                } else {
                    // Reached Flavor Core
                    const damage = enemy.boss ? 30 : 10;
                    gameState.health -= damage;
                    createParticles(enemy.x, enemy.y, '#FF0000', 20);
                    updateHUD();
                    if (gameState.health <= 0) {
                        showGameOver(false);
                    }
                    return false;
                }

                // Draw enemy
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();

                if (enemy.boss) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Draw emoji
                const fontSize = enemy.size * 1.3;
                ctx.font = `${fontSize}px Arial`;
                const offset = fontSize / 2;
                ctx.fillText(enemy.emoji, enemy.x - offset, enemy.y + offset / 2);

                // Health bar
                const barWidth = enemy.size * 2;
                const barY = enemy.y - enemy.size - 10;
                ctx.fillStyle = 'rgba(139, 0, 0, 0.8)';
                ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, 5);
                ctx.fillStyle = enemy.boss ? '#FFD700' : '#00FF00';
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillRect(enemy.x - barWidth/2, barY, barWidth * healthPercent, 5);

                return enemy.health > 0;
            });

            // Update and draw towers
            gameState.towers.forEach(tower => {
                // Draw tower base
                ctx.fillStyle = tower.color;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 22, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw emoji
                ctx.font = '28px Arial';
                ctx.fillText(tower.emoji, tower.x - 14, tower.y + 10);

                // Range indicator when hovering
                const rect = canvas.getBoundingClientRect();
                if (gameState.selectedTower) {
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Attack logic
                tower.cooldown--;
                if (tower.cooldown <= 0) {
                    // Find closest enemy in range
                    let target = null;
                    let minDist = Infinity;

                    gameState.enemies.forEach(e => {
                        const dist = Math.sqrt((e.x - tower.x) ** 2 + (e.y - tower.y) ** 2);
                        if (dist <= tower.range && dist < minDist) {
                            minDist = dist;
                            target = e;
                        }
                    });

                    if (target) {
                        gameState.projectiles.push({
                            x: tower.x,
                            y: tower.y,
                            targetX: target.x,
                            targetY: target.y,
                            target: target,
                            damage: tower.damage,
                            speed: 8,
                            color: tower.color,
                            splash: tower.splash,
                            emoji: tower.emoji
                        });
                        tower.cooldown = tower.fireRate;
                    }
                }
            });

            // Update and draw projectiles
            gameState.projectiles = gameState.projectiles.filter(proj => {
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < proj.speed) {
                    // Hit!
                    createParticles(proj.targetX, proj.targetY, proj.color, 8);

                    if (proj.splash) {
                        // Splash damage
                        gameState.enemies.forEach(e => {
                            const d = Math.sqrt((e.x - proj.targetX) ** 2 + (e.y - proj.targetY) ** 2);
                            if (d < proj.splash) {
                                const splashDmg = proj.damage * (1 - d / proj.splash);
                                e.health -= splashDmg;
                            }
                        });
                    } else {
                        // Single target
                        const enemy = gameState.enemies.find(e =>
                            Math.sqrt((e.x - proj.targetX) ** 2 + (e.y - proj.targetY) ** 2) < 30
                        );
                        if (enemy) enemy.health -= proj.damage;
                    }
                    return false;
                }

                proj.x += (dx / dist) * proj.speed;
                proj.y += (dy / dist) * proj.speed;

                // Draw projectile
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.stroke();

                return true;
            });

            // Check for defeated enemies
            const defeated = gameState.enemies.filter(e => e.health <= 0);
            defeated.forEach(e => {
                gameState.money += e.reward;
                createParticles(e.x, e.y, '#FFD700', 15);
            });

            // Check wave complete
            if (gameState.waveActive && gameState.enemies.length === 0) {
                gameState.waveActive = false;
                document.getElementById('startBtn').disabled = false;

                if (gameState.wave === gameState.maxWaves) {
                    // VICTORY!
                    showGameOver(true);
                } else {
                    const msg = gameState.wave === 4 ? 'Wave Complete! ‚ö†Ô∏è BOSS INCOMING!' :
                               gameState.wave === 7 ? 'Wave Complete! ‚ö†Ô∏è BIGGER BOSS INCOMING!' :
                               gameState.wave === 9 ? 'Wave Complete! üêâ FINAL BOSS NEXT! üêâ' :
                               `Wave ${gameState.wave} Complete! Ready for next wave?`;
                    document.getElementById('waveInfo').textContent = msg;
                }
            }

            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        // Show game over
        function showGameOver(won) {
            gameState.gameActive = false;
            const gameOverDiv = document.getElementById('gameOver');
            const title = document.getElementById('gameOverTitle');
            const text = document.getElementById('gameOverText');

            if (won) {
                title.textContent = 'üéâ LEGENDARY VICTORY! üéâ';
                title.style.color = '#FFD700';
                text.textContent = 'You defeated the Great Dragon King Noodle and saved the Flavor Core! All of Asia celebrates your culinary defense mastery!';
            } else {
                title.textContent = 'üíÄ Flavor Core Destroyed! üíÄ';
                title.style.color = '#FF4444';
                text.textContent = 'The corrupted food monsters have overwhelmed your defenses...';
            }

            gameOverDiv.style.display = 'block';
        }

        // Reset game
        function resetGame() {
            gameState = {
                money: 200,
                health: 100,
                wave: 0,
                maxWaves: 10,
                selectedTower: null,
                towers: [],
                enemies: [],
                projectiles: [],
                particles: [],
                gameActive: true,
                waveActive: false,
                path: [],
                bossActive: false
            };
            createPath();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('waveInfo').textContent = 'Click "Start Wave" to begin defending!';
            updateHUD();
            gameLoop();
        }

        // Initialize game
        createPath();
        updateHUD();
        gameLoop();
    </script>
</body>
</html>
